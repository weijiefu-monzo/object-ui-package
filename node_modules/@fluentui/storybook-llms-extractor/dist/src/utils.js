"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    convertHtmlToMarkdown: function() {
        return convertHtmlToMarkdown;
    },
    extractStorybookData: function() {
        return extractStorybookData;
    },
    generateFullFileContentFromStory: function() {
        return generateFullFileContentFromStory;
    },
    generateSummaryContent: function() {
        return generateSummaryContent;
    },
    writeFullDocsFiles: function() {
        return writeFullDocsFiles;
    },
    writeSummaryFile: function() {
        return writeSummaryFile;
    }
});
const _interop_require_default = require("@swc/helpers/_/_interop_require_default");
const _promises = require("node:fs/promises");
const _nodepath = require("node:path");
const _nodefs = require("node:fs");
const _playwright = require("playwright");
const _turndown = /*#__PURE__*/ _interop_require_default._(require("turndown"));
const _turndownplugingfm = require("turndown-plugin-gfm");
/**
 * Get content type based on file extension
 */ function getContentType(ext) {
    const contentTypes = {
        '.html': 'text/html',
        '.js': 'application/javascript',
        '.css': 'text/css',
        '.json': 'application/json',
        '.png': 'image/png',
        '.jpg': 'image/jpeg',
        '.jpeg': 'image/jpeg',
        '.gif': 'image/gif',
        '.svg': 'image/svg+xml',
        '.ico': 'image/x-icon',
        '.woff': 'font/woff',
        '.woff2': 'font/woff2',
        '.ttf': 'font/ttf',
        '.eot': 'application/vnd.ms-fontobject'
    };
    return contentTypes[ext] || 'application/octet-stream';
}
/**
 * Sets up static file serving using Playwright's page.route
 */ async function setupStaticRouting(page, distPath) {
    await page.route('**/*', async (route)=>{
        const url = new URL(route.request().url());
        let filePath = url.pathname;
        // Remove leading slash and resolve relative to distPath
        if (filePath.startsWith('/')) {
            filePath = filePath.substring(1);
        }
        // If no file extension, try to serve index.html
        if (!(0, _nodepath.extname)(filePath)) {
            filePath = (0, _nodepath.join)(filePath, 'index.html');
        }
        const fullPath = (0, _nodepath.resolve)(distPath, filePath);
        try {
            // Security check: ensure file is within distPath
            if ((0, _nodefs.existsSync)(fullPath) && fullPath.startsWith((0, _nodepath.resolve)(distPath))) {
                const content = await (0, _promises.readFile)(fullPath);
                const contentType = getContentType((0, _nodepath.extname)(fullPath));
                await route.fulfill({
                    status: 200,
                    contentType,
                    body: content,
                    headers: {
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                        'Access-Control-Allow-Headers': 'Content-Type, Authorization'
                    }
                });
            } else {
                await route.fulfill({
                    status: 404,
                    body: 'File not found'
                });
            }
        } catch (error) {
            console.error(`Error serving file ${fullPath}:`, error);
            await route.fulfill({
                status: 500,
                body: 'Internal server error'
            });
        }
    });
}
async function extractStorybookData({ distPath }) {
    console.log(`▶️ Setting up Playwright with static file routing...`);
    const browser = await _playwright.chromium.launch();
    const context = await browser.newContext({
        bypassCSP: true
    });
    try {
        console.log(`✔️ Static file routing configured for ${distPath}`);
        // Extract all stories from Storybook store
        const storeItems = await extractAllStoriesFromStorybook(context, distPath);
        // Extract content for all MDX pages
        for (const item of storeItems){
            const stories = Object.values(item.stories);
            if (stories.length > 0) {
                for (const story of stories){
                    if (story.parameters?.docsOnly) {
                        const pageUrl = `http://localhost/iframe.html?id=${story.id.replace('--page', '--docs')}`;
                        story.parameters.fullSource = await extractMDXStoryContentWithBrowser(pageUrl, context, distPath);
                    }
                }
            } else if (item.meta.parameters.fileName.endsWith('.mdx')) {
                const pageUrl = `http://localhost/iframe.html?id=${item.meta.id.replace('--page', '--docs')}`;
                item.stories[`${item.meta.id}`] = {
                    id: item.meta.id,
                    name: item.meta.title,
                    parameters: {
                        fullSource: await extractMDXStoryContentWithBrowser(pageUrl, context, distPath),
                        docsOnly: true,
                        docs: {}
                    }
                };
            }
        }
        console.log(`✔️ Extracted ${storeItems.length} stories from Storybook store.`);
        return storeItems;
    } finally{
        if (browser) {
            await browser.close();
        }
    }
}
/**
 * Extracts all stories from Storybook Client API store.
 */ async function extractAllStoriesFromStorybook(context, distPath) {
    const page = await context.newPage();
    // Set up static file routing for this page
    await setupStaticRouting(page, distPath);
    await page.goto(`http://localhost/iframe.html`);
    // Wait for the Storybook Client API to be loaded
    await page.waitForFunction(()=>{
        return window.__STORYBOOK_PREVIEW__;
    });
    const stories = await page.evaluate(async ()=>{
        /**
     * Retrieves the Storybook story store from the global window object.
     *
     * @param window Storybook globals object
     * @throws If unable to find Storybook preview or story store
     */ const getStoryStore = (window1)=>{
            const preview = window1.__STORYBOOK_PREVIEW__;
            if (!preview) {
                throw new Error('Unable to find Storybook preview');
            }
            if ('storyStore' in preview && preview.storyStore) {
                return preview.storyStore;
            }
            if ('storyStoreValue' in preview && preview.storyStoreValue) {
                return preview.storyStoreValue;
            }
            throw new Error('Unable to find Storybook story store');
        };
        const storyStore = getStoryStore(window);
        await storyStore.cacheAllCSFFiles();
        if (!storyStore.cachedCSFFiles) {
            throw new Error('Unable to find cached CSF files in Storybook store');
        }
        return Object.values(storyStore.cachedCSFFiles);
    });
    await page.close();
    return stories;
}
/**
 * Extracts `MDX` story content from a given URL using a browser.
 */ async function extractMDXStoryContentWithBrowser(url, context, distPath) {
    try {
        const page = await context.newPage();
        // Set up routing for this page
        await setupStaticRouting(page, distPath);
        console.log(`Extracting: "${url}"`);
        await page.goto(url);
        await page.waitForSelector('.sbdocs-content', {
            state: 'attached',
            timeout: 2000
        });
        const html = await page.locator('.sbdocs-content').innerHTML();
        await page.close();
        return convertHtmlToMarkdown(html);
    } catch (error) {
        console.error(`❌ Failed to extract: ${url}`, error);
        return '';
    }
}
async function convertHtmlToMarkdown(htmlContent) {
    /**
   * Disable HTML escaping for the Turndown service.
   *
   * https://github.com/mixmark-io/turndown?tab=readme-ov-file#overriding-turndownserviceprototypeescape
   **/ _turndown.default.prototype.escape = (str)=>str;
    const turndown = new _turndown.default({
        headingStyle: 'atx',
        hr: '---',
        bulletListMarker: '-',
        codeBlockStyle: 'fenced',
        fence: '```',
        emDelimiter: '_',
        strongDelimiter: '**',
        linkStyle: 'inlined'
    });
    // GitHub Flavored Markdown rules
    turndown.use([
        _turndownplugingfm.strikethrough,
        _turndownplugingfm.tables,
        _turndownplugingfm.taskListItems
    ]);
    // Code block rule
    turndown.addRule('codeBlock', {
        filter (node) {
            return node.nodeName === 'PRE';
        },
        replacement (content, node) {
            // Extract language from any element with class containing "language-"
            const languageElement = node.querySelector('[class*="language-"]');
            let language = '';
            if (languageElement) {
                const classNames = languageElement.className.split(' ');
                const languageClass = classNames.find((cls)=>cls.startsWith('language-'));
                if (languageClass) {
                    language = languageClass.replace('language-', '');
                }
            }
            const normalizedContent = content.trim();
            if (normalizedContent.startsWith('```')) {
                return normalizedContent;
            }
            return `\`\`\`${language}\n${normalizedContent}\n\`\`\``;
        }
    });
    // Remove unnecessary anchor links
    turndown.addRule('removeAnchorLinks', {
        filter (node) {
            return node.tagName === 'A' && (node.getAttribute('href') === null || node.getAttribute('href')?.startsWith('#') || node.getAttribute('aria-hidden') === 'true' || node.getAttribute('tabindex') === '-1');
        },
        replacement: ()=>''
    });
    // Remove other unnecessary elements
    turndown.addRule('removeElements', {
        filter: [
            'button',
            'style',
            'script',
            'img'
        ],
        replacement: ()=>''
    });
    // Convert to markdown
    return turndown.turndown(htmlContent);
}
async function writeSummaryFile(args, data) {
    const summaryContent = generateSummaryContent(args, data);
    await (0, _promises.writeFile)((0, _nodepath.join)(args.distPath, 'llms.txt'), summaryContent.join('\n'));
    console.log(`✅ LLMs docs summary written to ${(0, _nodepath.join)(args.distPath, 'llms.txt')}`);
}
function generateSummaryContent({ summaryTitle, summaryDescription, summaryBaseUrl, refs }, data) {
    // Initialize summary array with header content
    const summary = [
        `# ${summaryTitle}`,
        '',
        '> **Note:** This is a summary overview using the LLMs.txt format (https://llmstxt.org/). Each section links to its full documentation file in plain text (.txt) format. Click any link below to view the detailed documentation for that section.',
        '',
        summaryDescription,
        ''
    ];
    // Adds links to all components/pages
    for (const item of data){
        let description = item.meta.parameters?.docs?.description?.component || '';
        if (description) {
            description = `: ${description.split('\n')[0]}`;
        }
        summary.push(`- [${item.meta.title}](${summaryBaseUrl}/llms/${item.meta.id}.txt)${description}`);
    }
    // Adds links to all composed Storybook
    if (refs && refs.length > 0) {
        summary.push('');
        summary.push('## Optional');
        summary.push('');
        for (const ref of refs){
            summary.push(`- [${ref.title}](${ref.url.replace(/\/$/, '')}/llms.txt)`);
        }
        summary.push('');
    }
    return summary;
}
async function writeFullDocsFiles({ distPath }, data) {
    const llmsDir = (0, _nodepath.join)(distPath, 'llms');
    // Clean up `llms` directory
    await (0, _promises.rm)(llmsDir, {
        recursive: true,
        force: true
    });
    await (0, _promises.mkdir)(llmsDir, {
        recursive: true
    });
    for (const item of data){
        const filePath = (0, _nodepath.join)(llmsDir, `${item.meta.id}.txt`);
        const content = generateFullFileContentFromStory(item);
        await (0, _promises.writeFile)(filePath, content.join('\n'));
    }
}
function generateFullFileContentFromStory(item) {
    const stories = Object.values(item.stories);
    const isMDXPage = stories.every((s)=>s.parameters?.docsOnly);
    if (isMDXPage) {
        return stories.map((s)=>s.parameters?.fullSource ?? '').filter(Boolean);
    }
    const content = [];
    content.push(`# ${item.meta.title}`);
    content.push('');
    const description = extractStoryDescription(item);
    if (description) {
        content.push(description);
        content.push('');
    }
    const props = extractComponentProps(item.meta.component);
    if (props.length > 0) {
        content.push('## Props');
        content.push('');
        content.push(...generateComponentPropsTable(props));
        content.push('');
    }
    if (item.meta.subcomponents) {
        content.push('## Subcomponents');
        content.push('');
        for (const [name, subcomponent] of Object.entries(item.meta.subcomponents)){
            const docgen = subcomponent?.__docgenInfo;
            if (!docgen) {
                continue;
            }
            content.push('');
            content.push(`### ${name}`);
            content.push('');
            content.push(docgen.description ?? '');
            content.push('');
            const subcomponentProps = extractComponentProps(subcomponent);
            if (subcomponentProps.length > 0) {
                content.push('#### Props');
                content.push('');
                content.push(...generateComponentPropsTable(subcomponentProps));
                content.push('');
            }
        }
    }
    const examples = Object.values(item.stories).map((s)=>({
            title: s.name,
            description: s.parameters?.docs?.description?.story,
            source: s.parameters?.fullSource ?? s.parameters.docs?.source?.originalSource
        }));
    if (examples.length > 0) {
        content.push('## Examples');
        content.push('');
        for (const ex of examples){
            content.push('');
            content.push(`### ${ex.title}`);
            content.push('');
            if (ex.description) {
                content.push(ex.description);
                content.push('');
            }
            if (ex.source) {
                content.push('```tsx');
                content.push(ex.source.trim());
                content.push('```');
            }
        }
    }
    return content;
}
/**
 * Converts a docgen type object to a readable string for markdown tables.
 */ function stringifyPropType(type) {
    if (!type) {
        return '';
    }
    if (typeof type === 'string') {
        return type;
    }
    if (typeof type === 'object' && type !== null && 'name' in type && typeof type.name === 'string') {
        // Handle enums, unions, arrays, etc.
        if (type.name === 'enum' && Array.isArray(type.value)) {
            return type.value.map((v)=>typeof v.value === 'string' ? v.value : JSON.stringify(v.value)).join(' ');
        }
        if (type.name === 'union' && Array.isArray(type.value)) {
            return type.value.map((v)=>typeof v.value === 'string' ? v.value : JSON.stringify(v.value)).join(' ');
        }
        if (type.name === 'array' && type.value) {
            return `${stringifyPropType(type.value)}[]`;
        }
        if (type.name === 'signature' && type.value?.[0]?.value === 'function') {
            // Function signature
            return 'function';
        }
        return type.name;
    }
    return JSON.stringify(type);
}
/**
 * Extracts the description from a storybook story.
 */ function extractStoryDescription(story) {
    return story.meta.parameters?.docs?.description?.component || undefined;
}
/**
 * Extracts the props from a storybook story.
 */ function extractComponentProps(component) {
    const docgen = component?.__docgenInfo;
    if (!docgen || !docgen.props) {
        return [];
    }
    const props = [];
    for (const [name, arg] of Object.entries(docgen.props)){
        if (name === 'children') {
            continue;
        }
        props.push({
            name,
            description: arg.description || '',
            type: arg.type,
            defaultValue: typeof arg.defaultValue === 'string' ? arg.defaultValue : arg.defaultValue?.value || '',
            required: arg.required
        });
    }
    return props;
}
function generateComponentPropsTable(props) {
    const content = [];
    if (props.length === 0) {
        return content;
    }
    content.push('');
    content.push('| Name | Type | Required | Default | Description |');
    content.push('|------|------|----------|---------|-------------|');
    for (const prop of props){
        content.push(`| ${[
            `\`${prop.name}\``,
            `\`${stringifyPropType(prop.type)}\``,
            prop.required ? 'Yes' : 'No',
            prop.defaultValue ?? '',
            prop.description?.replace(/\n/g, ' ') ?? ''
        ].join(' | ')} |`);
    }
    content.push('');
    return content;
}

//# sourceMappingURL=utils.js.map